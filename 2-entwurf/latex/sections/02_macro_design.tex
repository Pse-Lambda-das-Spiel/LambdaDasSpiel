\section{Grobentwurf}

\subsection{libGDX}
%kann auch gelöscht werden wenn jemand was Besseres einfällt
libGDX ist ein auf Java basierendes Framework allein für Spieleentwicklung und wurde gewählt um die Entwicklung des Produkts zu vereinfachen.
Viele von uns benötigte Funktionalitäten sind in diesem Framework schon implementiert, wodurch wir erhebliche Implementierungsarbeit und auch Zeit einsparen.
Dabei wird es beispielsweise einfach gemacht die Benutzeroberfläche oder Animationen zu erstellen und zu verwalten.
Zusätzlich soll unsere Applikation auf mehreren Plattformen lauffähig sein, sodass libGDX es erlaubt durch eine einzige Code-Basis die Applikation möglichst plattformneutral zu halten 
und relativ einfach entsprechende, spezialisierte Programmversionen für Mobile Endgeräte oder Desktop zu erstellen.

\subsection{Model-View-Controller}
Das Prinzip von Model-View-Controller (MVC) ist allgemein weit verbreitet und heute schon nahezu Standard für Entwurf von Softwaresystemen. 
MVC erlaubt uns ein gut gekapseltes Programm zu erstellen. Dies erleichtert die Implementierung bzw. den Entwurf, da Klassen teils in sich abgeschlossen sind
und eine logische Einheit bilden. Durch MVC und unser dazugehöriges Beobachter-Muster (siehe Observer) erhalten Klassen eine lose Kopplung,
die Flexibilität und auch die einfache Wiederverwertung von Klassen ermöglicht, sollte das Programm oder Programmteile weiterentwickelt werden.
Im Gegensatz zum Standard MVC-Modell haben wir, aufgrund einer gewissen, schon von libGDX vorgegebenen Vermischung von View und Controller,
auf getrennte View und Controller verzichtet. So besteht unser Modell aus Model und "ViewControllern", wie man im Feinentwurf sehen wird.

\subsection{Observer}
Das Observer/Beobachter-Modell ist integraler Bestandteil unseres Entwurfs nach dem Model-View-Controller-Prinzip.
Es erzeugt eine starke Flexibilität der Implementierung, so können beobachtete Objekte und Beobachter beliebig untereinander ausgetauscht werden.
Dies erhöht die Modifizierbarkeit und Erweiterbarkeit des Programms enorm und erzwingt auch eine Abkapselung der Klassen.
Ebenfalls ermöglicht uns das Observer-Pattern eine Datenkonsistenz aufrecht zu erhalten. Ändert sich zum Beispiel das Spielerprofil, 
werden automatisch alle davon betroffenen Objekte aktualisiert.

\subsection{Visitor}

\subsection{Singleton-Pattern}
Da wir verschiedene Klassen benötigen von denen es aber nur ein Objekt geben soll und ein globaler sowie einfacher Zugriff auf diese Objekte geben soll, bietet sich das Singleton-Pattern natürlich besonders an. So gibt es beispielsweise die Klasse $\texttt{AssetModel}$, welche alle benötigten Ressourcen für die Applikation enthält und von mehreren Klassen gleichzeitig benutzt wird.

\subsection{Strategy}
